---
layout:     post   				    # 使用的布局（不需要改）
title:      multi-agent reinforcement learning   				# 标题 
subtitle:   AlphaStar #副标题
date:       2023-05-31 				# 时间
author:     Zhourui 						# 作者
header-img: img/1661857828280-01.jpeg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - study
---

## study
>摘要
强化学习旨在通过试错的方式来学习序列决策问题的最优策略。多智能体强化学习要解决群体智能相关的问题，其研究往往涉及群体内智能体之间的协作与对抗。在算法方面，解决此类群体问题的一个重要的途径是基于群体的多智能体强化学习方法，本文聚焦于多智能体强化学习和种群训练。主要围绕基于多智能体强化学习主宰星际争霸游戏这篇论文，研究它的训练过程，包括监督学习、单智能体的强化学习和多智能体学习。以及之后的种群训练方法PSRO。
Grandmaster level in StarCraft II using multi-agent reinforcement learning  
一、游戏简介
《星际争霸II》是一个实时进行的战略游戏。你可以从上帝视角观察和指挥部队，争夺战场的控制权，并最终击败你的对手。游戏的单人游戏战役主要聚焦于人类种族，但你可以在多人游戏比赛中使用以下三个《星际争霸II》的种族的任意一个：人类、星灵和异虫。
每个种族都拥有其独特的单位；这些单位在战场上各自有其特定的角色。结合不同的单位来组成一支多功能的部队，是走向胜利的常规道路之一。你能指挥的最基础的单位是工人。他们会采集资源，让你用来扩张基地，以及为你日渐庞大的部队招兵买马，同时他们也能建造新的建筑。一些高级单位在你的基地达到特定要求之后就会解锁，你需要建造特定建筑，或者研究相应的科技。在多人游戏比赛中，如果你将地图上敌人的所有建筑都摧毁，或者敌人向你投降，那么你就赢得了比赛。
与围棋相比，虽然都属于零和博弈，但还多了不完全信息(比如对手的信息是看不到的)、输入输出状态空间更庞大、存在海量先验信息、游戏预测困难的问题。

二、研究意义
现实智能体的相互竞争协调，使用多智能体强化学习方法来解决《星际争霸》的挑战。
如果采用自博弈（自己和自己玩）的方法来学习策略的话，随着学习的进行，可能会出现循环。例如，学习到的 B 策略打败了之前的 A 策略，接下来学习到的 C 策略打败了 B 策略，最后又重新学习到了 A 策略发现它能打败 C 策略。如果纯使用自博弈来学习，学习到的策略可能不能有效对抗人类策略。
SP,FSP,PFSP,区别
SP: self-play 自博弈（自己和自己玩）
FSP: Fictitious self play 训练过程中，每隔⼀段时间给⾃己存档，得到⼀个种群。均匀随机地从种群中选出对手与正在训练的智能体对战。但智能体与太菜的对⼿打浪费时间。
PFSP: Prioritized FSP 有针对性的在历史模型中选择对手，越困难的对手有越大的优化权重


三、环境设计

实体：在每个时刻，环境给神经网络N个长度为K的向量，各表示此刻智能体能够看⻅的N个实体的信息。实体数目不确定，列表向量形式传入神经网络。transformer处理不定长列表。
地图：在每个时刻，环境给神经网络20个176*200的矩阵，各表示此刻全局地图中的一些信息。
玩家数据：向量形式传入的标量数据。

动作类型：移动单位、升级建筑、移动摄像机
选中单位
目标
是否⽴即执⾏动作
是否重复动作
等候多久才接收下⼀次输入：模仿人类延迟

四、训练框图
先进行基于人类数据的监督学习，然后再进行使用联盟方法的强化学习。
监督学习:解决神经⽹络初始化的问题
监督学习目标是：学习人类对单位的操作以及建筑建造的操作。其中建筑建造的单元和顺序需要单独列出来训练，因为很多情况下，一些操作必须要有一些建筑作为前提。

AlphaStar会根据小地图数据o和建造操作数据z学习，并且以人类的操作a作为标签进行训练，得到合适的输出pi的神经网络。经过训练后，其得到的是三个种族的神经网络各一个。
z是从人类对局数据抽取出来的统计量，包括：
1）前20个建造的建筑物和单位
2）整局游戏中建造的单位、建筑，升级的科技和技能 (布尔向量表示)
强化学习:从奖励中学习
强化学习目标是：基于AC框架，通过不断的与其他玩家的对抗来进行学习。

AlphaStar会将自身观察的数据信息o输入AC框架下的神经网络。为了降低方差，其也会将对手的信息o'输入网络，输出策略 pi 和值函数 v 。
对于策略，其通过以相比监督学习网络输出策略的KL散度，利用V-trace来训策略网络，并提出UPGO技术帮助训练。
对于值函数，其通过基于R_t的TD(λ)方式更新，并同时输入对⼿数据。
统计量Z作为神经⽹络的输⼊传给策略网络和价值网络
技术细节 
专家数据的使用
1、监督学习预训练得到神经⽹络初始化
2、⼈类统计量Z⽤来计算伪奖励函数（建造顺序计算编辑距离、累计数据计算汉明距离）
2、人类统计量作为输入传给神经网络
4、监督学习loss和强化学习loss一起使用
多智能体学习：解决如何挑选对⼿的问题
核心思想：创建一个联盟League，联盟内有很多个体；通过不断的让联盟内部的个体之间相互对抗来进行强化学习训练，使得每个个体都能得到提升。经过不断的内部对抗，其得到的不是一个极度强大的个体，而是一个十分强大的群体。

主智能体 (Main Agent):正在训练的智能体及其祖先，重点培养对象
场上只有3个正在学习的主智能体 (每个种族一个)

每隔2×10^9个时间步之后就存档现在的策略
永不重设策略的参数

联盟利用者 (League Exploiter):能打败联盟里的所有智能体，它发现了全局盲点
场上有6个正在学习的联盟利用者 (每个种族2个)
按照PFSP给的概率与全联盟的对⼿对战
以70%胜率打败联盟中的所有人，或者距上次存档2×10^9个时间步之后就存档现在的策略
在存档的时候，有25%概率把场上的联盟利用者的策略重设成监督学习给出的初始化

主利用者 (Main Exploiter):能打败正在训练的主智能体，它发现了他们的弱点
场上有3个正在学习的主利用者 (每个种族一个)

以70%的胜率打败全部三个正在学习的主智能体，或者距上次存档4×10^9个时间步之后就存档现在的策略
每次存档之后就重设初始化参数

五、计算资源
三个种族，每个种族1个Main agent,1个Main expliter，两个League exploiter。用32块TPU训练44天。文章测试了三个版本：有监督学习之后的版本、学习了一半的版本 AlphaStar Mid（学习了 27 天）、学习完成之后的版本 AlphaStar Final（学习了 44 天）。
TPU：张量处理器，是 Google 开发的专用集成电路（ASIC），专门用于加速机器学习。与图形处理单元（GPU）相比，TPU 被设计用于进行大量的低精度计算（如 8 位的低精度），每焦耳功耗下的输入/输出操作更多。

六、实验结果分析

从左到右，第一个红线AlphaStar Supervised表示只进行监督学习，没有进行强化学习时的水平；第二个红线AlphaStar Mid表示进行了一半强化学习时的水平（32块TPU上学习27天）；第三个红线AlphaStar Final表示强化学习完成后的水平（32块TPU上学习44天）。 从上到下，Main agents是训练的主体，其分数随学习的进行而升高；League Agents由于每过一段时间都有一定的几率还原为人类策略模型的参数，因此策略的水平比较分散，总体上在Main agents和Main exploiters之间；Main exploiters由于每过一段时间也是会被还原为人类策略模型参数，因此一直保持在相对低的水平。
消融实验

定量分析了各个技术的作用。图b中“+Main Exploiters”和“+League Exploiters”是增加了对抗训练后的相对性能，对比算法“Main agents” 只使用自我博弈策略进行训练，加联盟训练者性能大幅提升。图e，加监督学习能提高性能，强化学习再加监督loss性能又提升，还是不能逃离人类数据。根据图g，智能体的水平随着APM限制的放宽先升高后降低。论文解释，APM限制的放宽使得智能体需要在相同时间内做出更多的决策，这使得智能体需要学习更多的“微决策”“微操作”，从而可能放慢了智能体的学习速度，拉低了智能体的水平。图k中，价值函数同时利用我方和敌方来训练，加入敌方后胜率高、估的准。
七、总结
1、⾼度复杂的神经⽹络融合了列表、图像、标量信息等输入
2、模仿学习和监督学习的成功运用
3、复杂的联盟训练策略
4、⼤量的计算资源


网络结构：整体上使用AC框架
价值函数网络

baseline：以人类为基础进行学习
lstm输出：所有之前观测和动作
策略函数网络

scalar_features—玩家数据和游戏统计信息
entity_list—游戏中的实体列表
lstm：存储过去的所有信息，将每一个time_step输入到LSTM，赋予各个时间段观测和动作时序性。

1、选择action type（what）
2、通过MLP确定delay (when)
3、同样使用MLP，确定是否要加入队列。因为APM有限制，有一些动作不能被立即执行，要加入Quene等待以后的时间执行。
4、对于动作的执行者(Which)，使用Pointer Network，输⼊一个序列，输出另⼀个序列。输出序列的元素来⾃于输入序列。直接获取entities作为输入，输出一个pointer直接指向输入的一个元素。根据场上的units挑一个子集作为对象。
5、对于被执行者的选择(Who)，需要location或者entities的信息。对于entities序列，使用NLP方法处理，对于locations图片信息，反卷积成minimap告诉游戏引擎。